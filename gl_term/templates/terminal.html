<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Web Terminal (multi-tab)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css"/>
  <style>
@font-face {
  font-family: "JetBrains Mono";
  font-style: normal;
  font-weight: 300;
  font-display: swap;
  src: url("/static/JetBrainsMono-Regular.woff2") format("woff2");
}
    :root{
      --bg:#1e1e1e;
      --top:#0f1720;
      --muted:#9aa4ad;
      --accent:#0b84ff;
      --button:#0a7;
      --danger:#ff5d5d;
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:"JetBrains Mono",monospace !important;border-radius: 3px;}
    /* Top bar / tabs */
    #topbar{
      box-sizing:border-box;
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px;
      background:var(--top);
      color:var(--muted);
      flex-wrap:wrap;
      row-gap:6px;
    }
    #tabs{
      display:flex;
      gap:6px;
      align-items:center;
      overflow:auto;
      padding:4px;
      flex:1 1 auto;
      min-width:0;
    }
    .tabbtn{
      display:flex;
      gap:8px;
      align-items:center;
      padding:6px 8px;
      border-radius:8px;
      background:#222;
      color:var(--muted);
      cursor:pointer;
      white-space:nowrap;
      font-size:13px;
    }
    .tabbtn.active{background:var(--accent); color:#fff;}
    .tab-label{max-width:120px; overflow:hidden;text-overflow:ellipsis; white-space:nowrap; display:inline-block; vertical-align:middle}
    .closebtn{
      background:transparent;border:0;color:#ccc;cursor:pointer;font-weight:600;padding:0 6px;border-radius:4px;
    }
    #newtab{
      flex:0 0 auto;
      padding:8px 12px;
      border-radius:8px;
      background:var(--button);
      color:#012;
      border:none;
      cursor:pointer;
      font-weight:600;
    }

    /* Terminal area */
    #termwrap{
      height:calc(100vh - 64px);
      position:relative;
      background:var(--bg);
    }
    .term-instance{position:absolute; inset:0; display:none}
    .term-instance.active{display:block}

    /* Toast confirm */
    #confirmToast{
      position:fixed;
      left:50%;
      transform:translateX(-50%) translateY(120%);
      bottom:18px;
      min-width:260px;
      max-width:90%;
      background:rgba(20,20,20,0.98);
      color:#eee;
      border-radius:10px;
      box-shadow:0 10px 30px rgba(0,0,0,0.6);
      padding:12px;
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      z-index:2147483647;
      transition:transform .22s cubic-bezier(.2,.9,.3,1),opacity .22s;
      opacity:0;
      pointer-events:none;
    }
    #confirmToast.show{ transform:translateX(-50%) translateY(0); opacity:1; pointer-events:auto; }
    #confirmToast .msg{flex:1;padding-right:8px;font-size:14px;color:var(--muted)}
    #confirmToast .actions{display:flex;gap:8px}
    .toast-btn{
      padding:6px 10px;border-radius:8px;border:0;cursor:pointer;font-weight:600
    }
    .toast-btn.ok{ background:var(--accent); color:#fff}
    .toast-btn.cancel{ background:#222; color:#ddd }

    /* Responsive tweaks */
    @media (max-width:720px){
      #topbar{padding:6px 8px; row-gap:8px}
      #newtab{padding:6px 8px; font-size:13px}
      .tab-label{max-width:80px}
      #termwrap{height:calc(100vh - 96px)}
    }
  </style>
</head>
<body>
  <div id="topbar" role="toolbar" aria-label="Terminal toolbar">
    <div id="tabs" role="tablist" aria-label="Terminal tabs"><button id="newtab" title="New Tab">+</button></div>
  </div>

  <div id="termwrap" aria-live="polite"></div>

  <!-- Toast confirmation (hidden by default) -->
  <div id="confirmToast" role="dialog" aria-hidden="true" aria-live="assertive">
    <div class="msg" id="toastMsg">Close this terminal tab?</div>
    <div class="actions">
      <button class="toast-btn cancel" id="toastCancel">Cancel</button>
      <button class="toast-btn ok" id="toastOK">Close</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/socket.io/client-dist/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>

  <script>
  (function(){
    const socket = io();
    const tabsEl = document.getElementById('tabs');
    const newTabBtn = document.getElementById('newtab');
    const termwrap = document.getElementById('termwrap');

    // Toast elements
    const toast = document.getElementById('confirmToast');
    const toastMsg = document.getElementById('toastMsg');
    const toastOK = document.getElementById('toastOK');
    const toastCancel = document.getElementById('toastCancel');

    // terminals map: tabId -> { term, container, button, closeBtn, local_echo, lineBuf }
    const terminals = {};
    // pending confirmation (tab id) shown in toast
    let pendingCloseTab = null;

    function switchToTab(tab) {
      for (const t in terminals) {
        const info = terminals[t];
        if (t === tab) {
          info.container.classList.add('active');
          info.button.classList.add('active');
          try { info.term.focus(); } catch(e){}
        } else {
          info.container.classList.remove('active');
          info.button.classList.remove('active');
        }
      }
    }

    function removeTabUI(tab) {
      const info = terminals[tab];
      if (!info) return;
      try { info.term.dispose(); } catch(e){}
      try { info.container.remove(); } catch(e){}
      try { info.button.remove(); } catch(e){}
      delete terminals[tab];
      // pick another tab to show
      const keys = Object.keys(terminals);
      if (keys.length) switchToTab(keys[0]);
    }

    // closeTab removes UI and notifies server to terminate; skipConfirm true -> no toast
    function closeTab(tab, skipConfirm=false) {
      if (!terminals[tab]) return;
      if (!skipConfirm) {
        // show toast confirm
        pendingCloseTab = tab;
        toastMsg.textContent = "Close tab " + tab.slice(0,8) + " and terminate its shell?";
        showToast();
        return;
      }

      // immediate close: emit to server then remove UI
      try { socket.emit('term_close', { tab }); } catch(e){}
      removeTabUI(tab);
      // if toast was showing for same tab, hide it
      if (pendingCloseTab === tab) {
        pendingCloseTab = null;
        hideToast();
      }
    }

    // show / hide toast
    function showToast(){
      toast.setAttribute('aria-hidden','false');
      toast.classList.add('show');
      // focus first actionable button
      toastCancel.focus();
    }
    function hideToast(){
      toast.classList.remove('show');
      toast.setAttribute('aria-hidden','true');
      pendingCloseTab = null;
    }

    function createTabElement(tab, local_echo) {
      // Button
      const btn = document.createElement('div');
      btn.className = 'tabbtn';
      btn.setAttribute('data-tab', tab);

      const label = document.createElement('span');
      label.className = 'tab-label';
      label.textContent = tab.slice(0,8);
      btn.appendChild(label);

      const close = document.createElement('button');
      close.className = 'closebtn';
      close.title = 'Close tab';
      close.innerText = 'âœ•';
      close.addEventListener('click', (ev) => {
        ev.stopPropagation();
        closeTab(tab, false); // will show toast
      });
      btn.appendChild(close);

      btn.addEventListener('click', () => switchToTab(tab));
      tabsEl.appendChild(btn);

      // Terminal container
      const cont = document.createElement('div');
      cont.className = 'term-instance';
      cont.id = 'term-' + tab;
      termwrap.appendChild(cont);

      // xterm
      const term = new Terminal({ cursorBlink:true, convertEol:true, scrollback:2000 });
      term.open(cont);
      term.focus();

      terminals[tab] = { term, container: cont, button: btn, closeBtn: close, local_echo: !!local_echo, lineBuf: "" };

      // handle keypresses
      term.onData(e => {
        const info = terminals[tab];
        if (info.local_echo) {
          // backspace
          if (e === '\x7f' || e === '\b') {
            term.write('\b \b');
            if (info.lineBuf.length) info.lineBuf = info.lineBuf.slice(0, -1);
            socket.emit('term_input', { tab, data: '\x7f' });
            return;
          }
          // enter
          if (e === '\r' || e === '\n') {
            const typed = info.lineBuf.replace(/\s+/g,' ').trim().toLowerCase();
            if (typed === 'cls' || typed === 'clear') term.clear();
            term.write('\r\n');
            socket.emit('term_input', { tab, data: '\r' });
            info.lineBuf = "";
            return;
          }
          // printable
          if (e >= ' ' && e <= '~') {
            info.lineBuf += e;
            term.write(e);
          } else {
            term.write(e);
          }
        }
        // always forward to server
        socket.emit('term_input', { tab, data: e });
      });

      // activate
      switchToTab(tab);
    }

    // create new tab on button
    newTabBtn.addEventListener('click', () => socket.emit('term_new'));

    // server responses
    socket.on('term_created', msg => {
      const tab = msg.tab;
      const local_echo = !!msg.local_echo;
      createTabElement(tab, local_echo);
    });

    socket.on('term_output', msg => {
      const tab = msg.tab;
      const out = msg.output || "";
      const info = terminals[tab];
      if (!info) return;
      try { info.term.write(out.replace(/\r?\n/g, '\r\n')); } catch(e){}

      // detect exit markers and auto-close (no toast)
      const exitMarkers = ["[terminal exited]", "[cmd exited]", "[process exited]", "[pty exited]", "[shell exited]", "[terminal closed]", "[terminal exited]"];
      for (const m of exitMarkers) {
        if (out.indexOf(m) !== -1) {
          // give the UI a short moment for final output, then close
          setTimeout(() => {
            if (terminals[tab]) removeTabUI(tab); // server should also send term_closed
            try { socket.emit('term_closed', { tab }); } catch(e){}
          }, 120);
          break;
        }
      }
    });

    // server explicitly closed
    socket.on('term_closed', msg => {
      const tab = msg.tab;
      if (!tab) return;
      // close without toast
      removeTabUI(tab);
    });

    // toast button handlers
    toastOK.addEventListener('click', () => {
      if (!pendingCloseTab) { hideToast(); return; }
      const t = pendingCloseTab;
      pendingCloseTab = null;
      hideToast();
      // perform immediate close
      try { socket.emit('term_close', { tab: t }); } catch(e){}
      removeTabUI(t);
    });

    toastCancel.addEventListener('click', () => {
      pendingCloseTab = null;
      hideToast();
    });

    // keyboard shortcuts for confirm (Esc => cancel)
    document.addEventListener('keydown', (e) => {
      if (!toast.classList.contains('show')) return;
      if (e.key === 'Escape') {
        pendingCloseTab = null;
        hideToast();
      }
    });

    // auto-create a tab on connect
    socket.on('connect', () => {
      socket.emit('term_new');
    });

    // expose for debug
    window._terminals = terminals;
  })();
  </script>
</body>
</html>
